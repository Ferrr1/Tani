import { useAuth } from "@/context/AuthContext";
import { supabase } from "@/lib/supabase";
import {
  CreateReceiptInput,
  ReceiptRow,
  UpdateReceiptInput,
} from "@/types/receipt";
import { ensureMoneyNum, ensureText } from "@/utils/expense";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

async function assertSeasonOwnership(userId: string, seasonId: string) {
  const { data, error } = await supabase
    .from("seasons")
    .select("id,user_id")
    .eq("id", seasonId)
    .maybeSingle();

  if (error) throw error;
  if (!data) throw new Error("Season tidak ditemukan.");
  if (data.user_id !== userId) {
    throw new Error("Season bukan milik user ini.");
  }
}

export const receiptRepo = {
  async list(
    userId: string,
    opts?: { seasonId?: string | "all" }
  ): Promise<ReceiptRow[]> {
    let q = supabase
      .from("receipts")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false });

    if (opts?.seasonId && opts.seasonId !== "all") {
      q = q.eq("season_id", opts.seasonId);
    }

    const { data, error } = await q;
    if (error) throw error;
    return (data || []) as ReceiptRow[];
  },

  async getById(userId: string, id: string): Promise<ReceiptRow | null> {
    const { data, error } = await supabase
      .from("receipts")
      .select("*")
      .eq("user_id", userId)
      .eq("id", id)
      .maybeSingle();
    if (error) throw error;
    return (data as ReceiptRow) ?? null;
  },

  async create(userId: string, input: CreateReceiptInput): Promise<ReceiptRow> {
    if (!userId) throw new Error("Tidak ada userId dari AuthContext.");
    ensureText(input.seasonId, "Season");
    ensureMoneyNum(input.quantity, "Kuantitas");
    ensureText(input.unitType, "Jenis satuan");
    ensureMoneyNum(input.unitPrice, "Harga satuan");

    // Optional: validasi kepemilikan season (lebih ramah error di UI)
    await assertSeasonOwnership(userId, input.seasonId);

    const payload = {
      user_id: userId,
      season_id: input.seasonId,
      quantity: input.quantity,
      unit_type: input.unitType,
      unit_price: input.unitPrice,
      // total -> generated by DB
    };

    const { data, error } = await supabase
      .from("receipts")
      .insert(payload)
      .select("*")
      .single();

    if (error) throw error;
    return data as ReceiptRow;
  },

  async update(userId: string, input: UpdateReceiptInput): Promise<ReceiptRow> {
    if (!input.id) throw new Error("ID receipt wajib diisi.");

    const patch: Record<string, any> = {};

    if (input.seasonId != null) {
      ensureText(input.seasonId, "Season");
      await assertSeasonOwnership(userId, input.seasonId);
      patch.season_id = input.seasonId;
    }
    if (input.quantity != null) {
      ensureMoneyNum(input.quantity, "Kuantitas");
      patch.quantity = input.quantity;
    }
    if (input.unitType != null) {
      ensureText(input.unitType, "Jenis satuan");
      patch.unit_type = input.unitType;
    }
    if (input.unitPrice != null) {
      ensureMoneyNum(input.unitPrice, "Harga satuan");
      patch.unit_price = input.unitPrice;
    }

    const { data, error } = await supabase
      .from("receipts")
      .update(patch)
      .eq("user_id", userId)
      .eq("id", input.id)
      .select("*")
      .single();

    if (error) throw error;
    return data as ReceiptRow;
  },

  async remove(userId: string, id: string): Promise<void> {
    const { error } = await supabase
      .from("receipts")
      .delete()
      .eq("user_id", userId)
      .eq("id", id);
    if (error) throw error;
  },
};

export function useReceiptService() {
  const { user, authReady } = useAuth(); // dari AuthContext

  const ensureUser = useCallback(() => {
    if (!authReady) throw new Error("Auth masih loading.");
    if (!user) throw new Error("Tidak ada sesi login.");
    return user;
  }, [authReady, user]);

  return {
    listReceipts: async (opts?: { seasonId?: string | "all" }) => {
      const u = ensureUser();
      return receiptRepo.list(u.id, opts);
    },

    getReceiptById: async (id: string) => {
      const u = ensureUser();
      return receiptRepo.getById(u.id, id);
    },

    createReceipt: async (input: CreateReceiptInput) => {
      const u = ensureUser();
      return receiptRepo.create(u.id, input);
    },

    updateReceipt: async (input: UpdateReceiptInput) => {
      const u = ensureUser();
      return receiptRepo.update(u.id, input);
    },

    deleteReceipt: async (id: string) => {
      const u = ensureUser();
      return receiptRepo.remove(u.id, id);
    },
  };
}

export function useReceiptList(initialSeasonId: string | "all" = "all") {
  const { user } = useAuth();

  const [rows, setRows] = useState<ReceiptRow[]>([]);
  const [loadingList, setLoadingList] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const [seasonId, setSeasonId] = useState<string | "all">(initialSeasonId);

  // guards
  const inFlight = useRef(false);
  const mounted = useRef(true);

  useEffect(() => {
    mounted.current = true;
    return () => {
      mounted.current = false;
    };
  }, []);

  const fetchOnce = useCallback(async () => {
    if (!user) return;
    if (inFlight.current) return;
    inFlight.current = true;
    try {
      if (mounted.current) setLoadingList(true);
      const data = await receiptRepo.list(user.id, { seasonId });
      if (!mounted.current) return;
      setRows(data);
    } catch (e) {
      console.warn(e);
    } finally {
      inFlight.current = false;
      if (mounted.current) setLoadingList(false);
    }
  }, [user, seasonId]);

  useEffect(() => {
    fetchOnce();
  }, [fetchOnce]);

  const refresh = useCallback(async () => {
    if (!user) return;
    if (inFlight.current) return;
    inFlight.current = true;
    try {
      if (mounted.current) setRefreshing(true);
      const data = await receiptRepo.list(user.id, { seasonId });
      if (!mounted.current) return;
      setRows(data);
    } catch (e) {
      console.warn(e);
    } finally {
      inFlight.current = false;
      if (mounted.current) setRefreshing(false);
    }
  }, [user, seasonId]);

  const data = useMemo(() => rows, [rows]);

  const grandTotal = useMemo(
    () => data.reduce((acc, r) => acc + (Number(r.total) || 0), 0),
    [data]
  );

  return {
    loading: loadingList,
    refreshing,
    rows,
    data,
    seasonId,
    setSeasonId,
    grandTotal,
    fetchOnce,
    refresh,
  };
}
