// services/receiptService.ts
import { useAuth } from "@/context/AuthContext";
import { supabase } from "@/lib/supabase";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

/** ===== Types (mirror table: public.receipts) ===== */
export type ReceiptRow = {
  id: string;
  user_id: string;
  season_id: string;

  quantity: number; // numeric(18,2)
  unit_type: string; // text
  unit_price: number; // numeric(18,2)
  total: number; // numeric(18,2) (generated)

  created_at: string; // ISO
  updated_at: string; // ISO
};

export type CreateReceiptInput = {
  seasonId: string;
  quantity: number;
  unitType: string;
  unitPrice: number;
  // NOTE: total -> generated by DB
};

export type UpdateReceiptInput = {
  id: string;
  seasonId?: string;
  quantity?: number;
  unitType?: string;
  unitPrice?: number;
  // NOTE: total -> generated by DB
};

/** ===== Helpers ===== */
const ensureMoneyNum = (n: unknown, name: string) => {
  if (typeof n !== "number" || Number.isNaN(n) || n < 0) {
    throw new Error(`${name} harus angka â‰¥ 0.`);
  }
};
const ensureText = (s: unknown, name: string) => {
  if (typeof s !== "string" || s.trim().length === 0) {
    throw new Error(`${name} wajib diisi.`);
  }
};

async function assertSeasonOwnership(userId: string, seasonId: string) {
  // Optional preflight (lebih ramah pesan error). Bisa dihapus jika mau hemat query.
  const { data, error } = await supabase
    .from("seasons")
    .select("id,user_id")
    .eq("id", seasonId)
    .maybeSingle();

  if (error) throw error;
  if (!data) throw new Error("Season tidak ditemukan.");
  if (data.user_id !== userId) {
    throw new Error("Season bukan milik user ini.");
  }
}

/** ===== Repo ===== */
export const receiptRepo = {
  async list(
    userId: string,
    opts?: { seasonId?: string | "all" }
  ): Promise<ReceiptRow[]> {
    let q = supabase
      .from("receipts")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false });

    if (opts?.seasonId && opts.seasonId !== "all") {
      q = q.eq("season_id", opts.seasonId);
    }

    const { data, error } = await q;
    if (error) throw error;
    return (data || []) as ReceiptRow[];
  },

  async getById(userId: string, id: string): Promise<ReceiptRow | null> {
    const { data, error } = await supabase
      .from("receipts")
      .select("*")
      .eq("user_id", userId)
      .eq("id", id)
      .maybeSingle();
    if (error) throw error;
    return (data as ReceiptRow) ?? null;
  },

  async create(userId: string, input: CreateReceiptInput): Promise<ReceiptRow> {
    if (!userId) throw new Error("Tidak ada userId dari AuthContext.");
    ensureText(input.seasonId, "Season");
    ensureMoneyNum(input.quantity, "Kuantitas");
    ensureText(input.unitType, "Jenis satuan");
    ensureMoneyNum(input.unitPrice, "Harga satuan");

    // Optional: validasi kepemilikan season (lebih ramah error di UI)
    await assertSeasonOwnership(userId, input.seasonId);

    const payload = {
      user_id: userId,
      season_id: input.seasonId,
      quantity: input.quantity,
      unit_type: input.unitType,
      unit_price: input.unitPrice,
      // total -> generated by DB
    };

    const { data, error } = await supabase
      .from("receipts")
      .insert(payload)
      .select("*")
      .single();

    if (error) throw error;
    return data as ReceiptRow;
  },

  async update(userId: string, input: UpdateReceiptInput): Promise<ReceiptRow> {
    if (!input.id) throw new Error("ID receipt wajib diisi.");

    const patch: Record<string, any> = {};

    if (input.seasonId != null) {
      ensureText(input.seasonId, "Season");
      await assertSeasonOwnership(userId, input.seasonId);
      patch.season_id = input.seasonId;
    }
    if (input.quantity != null) {
      ensureMoneyNum(input.quantity, "Kuantitas");
      patch.quantity = input.quantity;
    }
    if (input.unitType != null) {
      ensureText(input.unitType, "Jenis satuan");
      patch.unit_type = input.unitType;
    }
    if (input.unitPrice != null) {
      ensureMoneyNum(input.unitPrice, "Harga satuan");
      patch.unit_price = input.unitPrice;
    }

    const { data, error } = await supabase
      .from("receipts")
      .update(patch)
      .eq("user_id", userId)
      .eq("id", input.id)
      .select("*")
      .single();

    if (error) throw error;
    return data as ReceiptRow;
  },

  async remove(userId: string, id: string): Promise<void> {
    const { error } = await supabase
      .from("receipts")
      .delete()
      .eq("user_id", userId)
      .eq("id", id);
    if (error) throw error;
  },
};

/** ===== Hook actions (Auth-aware) ===== */
export function useReceiptService() {
  const { user, loading } = useAuth(); // dari AuthContext

  const ensureUser = () => {
    if (loading) throw new Error("Auth masih loading.");
    if (!user) throw new Error("Tidak ada sesi login.");
    return user;
  };

  return {
    loading,

    listReceipts: async (opts?: { seasonId?: string | "all" }) => {
      const u = ensureUser();
      return receiptRepo.list(u.id, opts);
    },

    getReceiptById: async (id: string) => {
      const u = ensureUser();
      return receiptRepo.getById(u.id, id);
    },

    createReceipt: async (input: CreateReceiptInput) => {
      const u = ensureUser();
      return receiptRepo.create(u.id, input);
    },

    updateReceipt: async (input: UpdateReceiptInput) => {
      const u = ensureUser();
      return receiptRepo.update(u.id, input);
    },

    deleteReceipt: async (id: string) => {
      const u = ensureUser();
      return receiptRepo.remove(u.id, id);
    },
  };
}

/** ===== List hook (filter by season, anti-duplicate fetch, preserve filter) ===== */
export function useReceiptList(initialSeasonId: string | "all" = "all") {
  const { user, loading } = useAuth();

  const [rows, setRows] = useState<ReceiptRow[]>([]);
  const [loadingList, setLoadingList] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const [seasonId, setSeasonId] = useState<string | "all">(initialSeasonId);

  // guards
  const inFlight = useRef(false);
  const mounted = useRef(true);

  useEffect(() => {
    mounted.current = true;
    return () => {
      mounted.current = false;
    };
  }, []);

  const fetchOnce = useCallback(async () => {
    if (loading || !user) return;
    if (inFlight.current) return;
    inFlight.current = true;
    try {
      if (mounted.current) setLoadingList(true);
      const data = await receiptRepo.list(user.id, { seasonId });
      if (!mounted.current) return;
      setRows(data);
    } catch (e) {
      console.warn(e);
    } finally {
      inFlight.current = false;
      if (mounted.current) setLoadingList(false);
    }
  }, [loading, user, seasonId]);

  // initial & when user changes OR season filter changes
  useEffect(() => {
    fetchOnce();
  }, [fetchOnce]);

  const refresh = useCallback(async () => {
    if (loading || !user) return;
    if (inFlight.current) return;
    inFlight.current = true;
    try {
      if (mounted.current) setRefreshing(true);
      const data = await receiptRepo.list(user.id, { seasonId });
      if (!mounted.current) return;
      setRows(data);
    } catch (e) {
      console.warn(e);
    } finally {
      inFlight.current = false;
      if (mounted.current) setRefreshing(false);
    }
  }, [loading, user, seasonId]);

  // optional: sorting terbaru berdasarkan created_at (sudah di query)
  const data = useMemo(() => rows, [rows]);

  // agregat (kalau perlu di UI; aman meski total dari DB)
  const grandTotal = useMemo(
    () => data.reduce((acc, r) => acc + (Number(r.total) || 0), 0),
    [data]
  );

  return {
    // state untuk UI
    loading: loadingList || loading,
    refreshing,
    rows, // mentah
    data, // alias
    seasonId,
    setSeasonId,

    // agregasi
    grandTotal,

    // actions
    fetchOnce,
    refresh,
  };
}
